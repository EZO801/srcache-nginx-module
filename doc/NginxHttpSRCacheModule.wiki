= Name =

'''ngx_srcache''' - Transparent subrequest-based caching layout for arbitrary nginx locations

''This module is not distributed with the Nginx source.'' See [[#Installation|the installation instructions]].

= Status =

This module is production ready.

= Version =

This document describes srcache-nginx-module [https://github.com/agentzh/echo-nginx-module/downloads v0.12rc6] released on 30 June 2011.

= Synopsis =

    location /foo {
        charset utf-8; # or some other encoding
        default_type text/plain; # or some other MIME type

        set $key $uri$args;
        srcache_fetch GET /memc $key;
        srcache_store PUT /memc $key;

        # proxy_pass/fastcgi_pass/drizzle_pass/echo/etc...
        # or even static files on the disk
    }

    location /memc {
        set $memc_key $query_string;
        set $memc_exptime 300;
        memc_pass 127.0.0.1:11211;
    }

= Description =

This module provides a transparent caching layer for arbitrary nginx locations (like those use an upstream or even serve static disk files).

Usually, [[NginxHttpMemcModule]] is used together with this module to provide a concrete caching storage backend. But technically, any modules that provide a REST interface can be used as the fetching and storage subrequests used by this module.

For main requests, the [[#srcache_fetch|srcache_fetch]] directive works at the end of the access phase, so the [[NginxHttpAccessModule|standard access module]]'s [[NginxHttpAccessModule#allow|allow]] and [[NginxHttpAccessModule#deny|deny]] direcives run ''before'' ours, which is usually the desired behavior for security reasons.

== Subrequest caching ==

For subrequests, we explicitly disallow the use of this module because it's too difficult to get right. There used to be an implementation but it was buggy and I finally gave up fixing it and abandoned it.

However, if you're using [[NginxHttpLuaModule]], it's easy to do subrequest caching in Lua all by yourself. That is, first issue a subrequest to an [[NginxHttpMemcModule]] location to do an explicit cache lookup, if cache hit, just use the cached data returned; otherwise, fall back to the true backend, and finally do a cache insertion to feed the data into the cache.

Using this module for main request caching and Lua for subrequest caching is the approach that we're taking in our business. This hybrid solution works great in production.

== Distributed Memcached Caching ==

Here is a simple example demonstrating a distributed memcached caching mechanism built atop this module. Suppose we do have three different memcacached nodes and we use simple modulo to hash our keys.

<geshi lang="nginx">
    server {
        upstream moon {
            server 10.62.136.54:11211;
        }

        upstream earth {
            server 10.62.136.55:11211;
        }

        upstream sun {
            server 10.62.136.56:11211;
        }

        upstream_list universe moon earth sun;

        location = /memc {
            internal;

            set_unescape_uri $memc_key $arg_key;
            set_hashed_upstream $backend universe $memc_key;
            set $memc_exptime 3600; # in seconds
            memc_pass $backend;
        }

        location / {
            set $key $uri;
            srcache_fetch GET /memc $key;
            srcache_store PUT /memc $key;

            # proxy_pass/fastcgi_pass/content_by_lua/drizzle_pass/...
        }
    }
</geshi>
Here's what is going on in the sample above:
# We first define three upstreams, <code>moon</code>, <code>earth</code>, and <code>sun</code>. These are our three memcached servers.
# And then we group them together as an upstream list entity named <code>universe</code> with the <code>upstream_list</code> directive provided by [[NginxHttpSetMiscModule]].
# After that, we define an internal location named <code>/memc</code> for talking to the memcached cluster.
# In this <code>/memc</code> location, we first unescape the <code>key</code> URI argument in case that it contains special characters like spaces (using the [[NginxHttpSetMiscModule#set_unescape_uri|set_unescape_uri]] directive), and then use the [[NginxHttpSetMiscModule#set_hashed_upstream|set_hashed_upstream]] directive to hash our [[NginxHttpMemcModule#$memc_key|$memc_key]] over the upsteam list <code>universe</code>, so as to obtain a concrete upstream name to be assigned to the variable <code>$backend</code>.
# We pass this <code>$backend</code> variable into the [[NginxHttpMemcModule#memc_pass|memc_pass]] directive. The <code>$backend</code> variable can hold a value among <code>moon</code>, <code>earth</code>, and <code>sun</code>.
# Also, we define the memcached caching expiration time to be 3600 seconds (i.e., an hour) by overriding the [[NginxHttpMemcModule#$memc_exptime|$memc_exptime]] variable.
# In our main public location <code>/</code>, we configure the <code>$uri</code> variable as our cache key, and then configure [[#srcache_fetch|srcache_fetch]] for cache lookups and [[#srcache_store|srcache_store]] for cache updates. We're using two subrequests to our <code>/memc</code> location defined earlier in these two directives.

One can use [[NginxHttpLuaModule]]'s [[NginxHttpLuaModule#set_by_lua|set_by_lua]] or [[NginxHttpLuaModule#rewrite_by_lua|rewrite_by_lua]] directives to inject custom Lua code to compute the <code>$backend</code> and/or <code>$key</code> variables in the sample above.

One thing that should be taken care of is that memcached does have restriction on key lengths, i.e., 250 bytes, so for keys that may be very long, one could use the [[NginxHttpSetMiscModule#set_md5|set_md5]] directive or its friends to pre-hash the key to a fixed-length digest before assigning it to <code>$memc_key</code> in the <code>/memc</code> location or the like.

Further, one can utilize the [[#srcache_fetch_skip|srcache_fetch_skip]] and [[#srcache_store_skip|srcache_store_skip]] directives to control what to cache and what not on a per-request basis, and Lua can also be used here in a similar way. So the possibility is really unlimited.

= Directives =

== srcache_fetch ==
'''syntax:''' ''srcache_fetch <method> <uri> <args>?''

'''default:''' ''no''

'''context:''' ''http, server, location, location if''

'''phase:''' ''access tail''

This directive registers an access phase handler that will issue an Nginx subrequest to lookup the cache.

When the subrequest returns status code other than <code>200</code>, than a cache miss is signaled and the control flow will continue to the later phases including the content phase configured by [[NginxHttpProxyModule]], [[NginxHttpFcgiModule]], and others. If the subrequest returns <code>200 OK</code>, then a cache miss is signaled and this module will send the subrequest's response as the current main request's response to the client directly.

This directive will always run at the end of the access phase, such that [[NginxHttpAccessModule]]'s [[NginxHttpAccessModule#allow|allow]] and [[NginxHttpAccessModule#deny|deny]] will always run ''before'' this.

You can use the [[#srcache_fetch_skip|srcache_fetch_skip]] directive to disable cache look-up selectively.

== srcache_fetch_skip ==
'''syntax:''' ''srcache_fetch_skip <flag>''

'''default:''' ''srcache_fetch_skip 0''

'''context:''' ''http, server, location, location if''

The <code><flag></code> argument supports nginx variables. When this argument's value is not empty ''and'' not equal to <code>0</code>, then the fetching process will be unconditionally skipped.

For example, to skip caching requests which have a cookie named <code>foo</code> with the value <code>bar</code>, we can write

<geshi lang="nginx">
    location / {
        set $key ...;
        set_by_lua $skip '
            if ngx.var.cookie_foo == "bar" then
                return 1
            end
            return 0
        ';

        srcache_fetch_skip $skip;
        srcache_store_skip $skip;

        srcache_fetch GET /memc $key;
        srcache_store GET /memc $key;

        # proxy_pass/fastcgi_pass/content_by_lua/...
    }
</geshi>
where [[NginxHttpLuaModule]] is used to calculate the value of the <code>$skip</code> variable at the (earlier) rewrite phase. Similarly, the <code>$key</code> variable can be computed by Lua using the [[NginxHttpLuaModule#set_by_lua|set_by_lua]] or [[NginxHttpLuaModule#rewrite_by_lua|rewrite_by_lua]] directive too.

== srcache_store ==
'''syntax:''' ''srcache_store <method> <uri> <args>?''

'''default:''' ''no''

'''context:''' ''http, server, location, location if''

'''phase:''' ''output filter''

This directive registers an output filter handler that will issue an Nginx subrequest to save the response of the current main request into a cache backend. The status code of the subrequest will be ignored.

You can use the [[#srcache_store_skip|srcache_store_skip]] and [[#srcache_store_max_size|srcache_store_max_size]] directives to disable caching for certain requests in case of a cache miss.

This directive works in an output filter.

== srcache_store_max_size ==
'''syntax:''' ''srcache_store_max_size <size>''

'''default:''' ''srcache_store_max_size 0''

'''context:''' ''http, server, location, location if''

When the response body length is exceeding this size, this module will not try to store the response body into the cache using the subrequest template that is specified in [[#srcache_store|srcache_store]].

This is particular useful when using cache storage backend that does have a hard upper limit on the input data. For example, for Memcached server, the limit is usually <code>1 MB</code>.

When <code>0</code> is specified (the default value), there's no limit check at all.

== srcache_store_skip ==
'''syntax:''' ''srcache_store_skip <flag>''

'''default:''' ''srcache_store_skip 0''

The <code><flag></code> argument supports Nginx variables. When this argument's value is not empty ''and'' not equal to <code>0</code>, then the storing process will be unconditionally skipped.

Here's an example using Lua to set $nocache to avoid storing URIs that contain the string "/tmp":

<geshi lang="nginx">
    set_by_lua $nocache '
        if string.match(ngx.var.uri, "/tmp") then
            return 1
        end
        return 0';

    srcache_store_skip $nocache;
</geshi>

= Known Issues =
* On certain systems, enabling aio and/or sendfile may stop [[#srcache_store|srcache_store]] from working. You can disable them in the locations configured by [[#srcache_store|srcache_store]].

= Caveats =
* For now, ngx_srcache does not cache response headers. So it's necessary to use the [[NginxHttpCharsetModule#charset|charset]], [[NginxHttpCoreModule#default_type|default_type]] and [[NginxHttpHeadersModule#add_header|add_header]] directives to explicitly set the <code>Content-Type</code> header and etc. Therefore, it's probably a bad idea to combine this module with backends that return varying response headers. Support for response header caching is a TODO and you're very welcome to submit patches for this :)
* It's recommended to disable your backend server's gzip compression and use nginx's [[NginxHttpGzipModule]] to do the job. In case of [[NginxHttpProxyModule]], you can use the following configure setting to disable backend gzip compression:
<geshi lang="nginx">
    proxy_set_header  Accept-Encoding  "";
</geshi>


= Installation =

It's recommended to install this module as well as the Nginx core and many other goodies via the [http://openresty.org ngx_openresty bundle]. It's the easiest way and most safe way to set things up. See OpenResty's [http://openresty.org/#Installation installation instructions] for details.

Alternatively, you can build Nginx with this module all by yourself:

* Grab the nginx source code from [http://nginx.org nginx.org], for example, the version 1.0.5 (see [[#Compatibility|Nginx Compatibility]]),
* and then download the latest version of the release tarball of this module from srcache-nginx-module [http://github.com/agentzh/srcache-nginx-module/downloads file list],
* and finally build the Nginx source with this module
<geshi lang="nginx">
     $ wget 'http://sysoev.ru/nginx/nginx-1.0.5.tar.gz'
     $ tar -xzvf nginx-1.0.5.tar.gz
     $ cd nginx-1.0.5/
     
     # Here we assume you would install you nginx under /opt/nginx/.
     $ ./configure --prefix=/opt/nginx \
             --add-module=/path/to/srcache-nginx-module
  
     $ make -j2
     $ make install
</geshi>

= Compatibility =

The following versions of Nginx should work with this module:

* 1.0.x (last tested: 1.0.5)
* 0.9.x (last tested: 0.9.4)
* 0.8.x (last tested: 0.8.54)
* 0.7.x >= 0.7.46 (last tested: 0.7.68)

Earlier versions of Nginx like 0.6.x and 0.5.x, as well as latest nginx 0.8.42+ will ''not'' work.

If you find that any particular version of Nginx above 0.7.44 does not work with this module, please consider reporting a bug.

= Report Bugs =
Although a lot of effort has been put into testing and code tuning, there must be some serious bugs lurking somewhere in this module. So whenever you are bitten by any quirks, please don't hesitate to

* create a ticket on the [http://github.com/agentzh/srcache-nginx-module/issues issue tracking interface] on GitHub.
* or send a bug report or even patches to the [http://mailman.nginx.org/mailman/listinfo/nginx nginx mailing list].

= Source Repository =
Available on github at [http://github.com/agentzh/srcache-nginx-module agentzh/srcache-nginx-module].

= ChangeLog =

= Test Suite =
This module comes with a Perl-driven test suite. The [http://github.com/agentzh/srcache-nginx-module/tree/master/test/t test cases] are [http://github.com/agentzh/srcache-nginx-module/blob/master/test/t/main-req.t declarative] too. Thanks to the [http://search.cpan.org/perldoc?Test::Base Test::Nginx] module in the Perl world.

To run it on your side:
<geshi lang="bash">
    $ PATH=/path/to/your/nginx-with-srcache-module:$PATH prove -r t
</geshi>
You need to terminate any Nginx processes before running the test suite if you have changed the Nginx server binary.

Because a single nginx server (by default, <code>localhost:1984</code>) is used across all the test scripts (<code>.t</code> files), it's meaningless to run the test suite in parallel by specifying <code>-jN</code> when invoking the <code>prove</code> utility.

Some parts of the test suite requires modules [[NginxHttpRewriteModule]], [[NginxHttpEchoModule]], [[NginxHttpRdsJsonModule]], and [[NginxHttpDrizzleModule]] to be enabled as well when building Nginx.

= TODO =
* add support for headers caching.

= Getting involved =
You'll be very welcomed to submit patches to the author or just ask for a commit bit to the source repository on GitHub.

= Author =
Zhang "agentzh" Yichun (章亦春) <agentzh@gmail.com>

= Copyright & License =
Copyright (c) 2010, 2011 Taobao Inc., Alibaba Group ( http://www.taobao.com ).

Copyright (c) 2010, 2011, Zhang "agentzh" Yichun (章亦春) <agentzh@gmail.com>.

This module is licensed under the terms of the BSD license.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

= See Also =
* [[NginxHttpMemcModule]]
* [[NginxHttpLuaModule]]
* [[NginxHttpSetMiscModule]]
* The [http://openresty.org ngx_openresty bundle]

